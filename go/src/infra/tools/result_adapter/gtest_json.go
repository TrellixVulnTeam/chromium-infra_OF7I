// Copyright 2022 The LUCI Authors. All rights reserved.
// Use of this source code is governed under the Apache License, Version 2.0
// that can be found in the LICENSE file.

package main

import (
	"bytes"
	"context"
	"encoding/json"
	"io"
	"regexp"
	"strconv"
	"strings"

	"go.chromium.org/luci/common/errors"
	"go.chromium.org/luci/resultdb/pbutil"
	pb "go.chromium.org/luci/resultdb/proto/v1"
	sinkpb "go.chromium.org/luci/resultdb/sink/proto/v1"
)

var failureMessageRE = regexp.MustCompile(`(.*):([0-9]+).*`)

// GTestJsonResults represents the structure of the json generated by the
// gtest flag gtest_output when selecting the json format.
//
// Fields not used by Test Results are omitted.
type GTestJsonResults struct {
	TestSuites []*GTestJsonTestSuites `json:"testsuites"`
}

// GTestJsonTestSuites represents all the tests.
//
// Fields not used by Test Results are omitted.
type GTestJsonTestSuites struct {
	TestSuite []*GTestJsonTestSuite `json:"testsuite"`
}

// GTestJsonTestSuite represents one run of a test.
//
// Fields not used by Test Results are omitted.
type GTestJsonTestSuite struct {
	ClassName string `json:"classname"`
	Name      string `json:"name"`
	Result    string `json:"result"`
	Time      string `json:"time"`

	Failures []*GTestJsonFailures `json:"failures"`
}

// GTestJsonFailures represents the failures
//
// Fields not used by Test Results are omitted.
type GTestJsonFailures struct {
	Failure string `json:"failure"`
}

// ConvertFromJSON reads the provided reader into the receiver.
//
// The receiver is cleared and its fields overwritten.
func (r *GTestJsonResults) ConvertFromJSON(reader io.Reader) error {
	*r = GTestJsonResults{}
	if err := json.NewDecoder(reader).Decode(r); err != nil {
		return err
	}

	return nil
}

// ToProtos converts test results in r to []*sinkpb.TestResult.
func (r *GTestJsonResults) ToProtos(ctx context.Context) ([]*sinkpb.TestResult, error) {
	var ret []*sinkpb.TestResult

	var buf bytes.Buffer
	for _, data := range r.TestSuites {
		for i, result := range data.TestSuite {
			testID := result.ClassName + "." + result.Name
			// Store the processed test result into the correct part of the overall map.
			rpb, err := r.convertTestResult(ctx, &buf, testID, result)
			if err != nil {
				return nil, errors.Annotate(err,
					"iteration %d of test %s failed to convert run result", i, testID).Err()
			}

			ret = append(ret, rpb)
		}
	}

	return ret, nil
}

func fromGTestJsonStatus(s string, failed bool) (status pb.TestStatus, expected bool, err error) {
	if failed {
		return pb.TestStatus_FAIL, false, nil
	} else if s == "SKIPPED" {
		return pb.TestStatus_SKIP, false, nil
	} else if s == "SUPPRESSED" {
		return pb.TestStatus_SKIP, true, nil
	} else if s == "COMPLETED" {
		return pb.TestStatus_PASS, true, nil
	}
	// This would only happen if the set of possible result statuses change and resultdb has
	// not been updated to match.
	return pb.TestStatus_STATUS_UNSPECIFIED, false, errors.Reason("unknown result status %q", s).Err()
}

func (r *GTestJsonResults) convertTestResult(ctx context.Context, buf *bytes.Buffer, testID string, result *GTestJsonTestSuite) (*sinkpb.TestResult, error) {
	var failure *pb.FailureReason
	if len(result.Failures) > 0 {
		failure = &pb.FailureReason{PrimaryErrorMessage: result.Failures[0].Failure}
	}
	status, expected, err := fromGTestJsonStatus(result.Result, failure != nil)
	if err != nil {
		return nil, err
	}

	tr := &sinkpb.TestResult{
		TestId:   testID,
		Expected: expected,
		Status:   status,
		Tags: pbutil.StringPairs(
			"test_name", testID,
		),
		TestMetadata:  &pb.TestMetadata{Name: testID},
		FailureReason: failure,
	}
	if expected && status == pb.TestStatus_SKIP {
		tr.Tags = append(tr.Tags, pbutil.StringPair("disabled_test", "true"))
	}

	t, err := strconv.ParseFloat(strings.TrimRight(result.Time, "s"), 64)
	if err == nil {
		tr.Duration = msToDuration(t * 1000)
	}
	if failure != nil {
		failureMessage := failure.PrimaryErrorMessage
		tr.SummaryHtml = "<p>" + failureMessage + "</p>"

		if match := failureMessageRE.FindStringSubmatch(failureMessage); match != nil {
			file := normalizePath(match[1])
			// For some reason, many file paths start with "../../", followed by
			// the correct path. Strip the prefix.
			file = stripRepeatedPrefixes(file, "../")
			file = ensureLeadingDoubleSlash(file)
			line, _ := strconv.ParseInt(match[2], 0, 32)
			tr.TestMetadata.Location = &pb.TestLocation{
				// WebRTC is currently the only user of this adapter.
				Repo:     webrtcSrcRepo,
				FileName: file,
				Line:     int32(line),
			}
		}
	}

	return tr, nil
}
